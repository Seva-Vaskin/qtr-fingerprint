\section{Introduction}

Задача поиска подграфа в возникает во многих областях, в том числе в биологии. Например, химические соединения представимы в виде графа, а задача поиска химических соединений содержащих данный фрагмент,в больших базах данных является важной подзадачей в процессе разработки лекарств.
{\color{red} Возможно, пример стоит выкинуть}
{

\begin{wrapfigure}{l}{0.5\textwidth}
    \includegraphics[width=0.35\textwidth]{img/abstract_example.png}
    \caption{Пример молекулы и её подструктуры}
    \label{figure:example_substructure_molecule}
\end{wrapfigure}

Например, молекула на рисунке \ref{figure:example_substructure_molecule} является активной, но не может быть использована по причине:
\begin{itemize}
  \item фармакологических проблем (ADMET - absorption, distribution, metabolism, excretion and toxicity)
  \item защищенности патентом
\end{itemize}

Мы знаем что активность данной молекулы обусловлена выделенным фрагментом.

Значит существует вероятность найти активные молекулы среди ее производных, содержащих данный фрагмент.

}

\hfill

Однако задача поиска подграфа в графе является NP-полной, поэтому эффективное решение в общем случае неизвестно. Тем не менее, можно применить эвристические методы ускорения поиска.

A typical pattern to achieve this is the so-called Filter-and-Verification paradigm, which proceeds in two steps. First, a fast filtering step is performed, that significantly reduces the size of the potential solution set by eliminating candidates with a heuristic, then a verification step tries to verify the subgraph relationship for the remaining candidates by a subgraph somorphism test. {\color{red}Абзац сворован из CT-index}

Основным методом реализации фильтрации является выделение фич и построение индекса. Каждая фича может быть бинарной или количественной. Предполагается, что если в графе $Q_1$ есть фича $X $, а в графе $Q_2$ её нет, то $Q_1$ не может быть подструктурой $Q_2$ . Аналогичное рассуждение можно провести для количественных фич. 

{\color{red} кажется, можно либо выкинуть пример, либо сделать его описание проще}
Рассмотрим примеры фичей на базе данных из двух молекул и одного запроса к данной базе, показанных на рисунке \ref{figure:features_example}

\begin{itemize}
  \item Примером бинарной фичи может быть <<Наличие брома>>. По данной фиче при выполнении запроса \ref{figure:features_example:2} можно отфильтровать молекулу \ref{figure:features_example:0}, так как понятно, что в запросе \ref{figure:features_example:2} есть бром, а в молекуле \ref{figure:features_example:0} его нет, поэтому \ref{figure:features_example:2} не может быть подграфом \ref{figure:features_example:0}. Однако, как в \ref{figure:features_example:2}, так и в \ref{figure:features_example:1} есть бром. Поэтому данная фича не отфильтрует \ref{figure:features_example:1} и придётся запускать алгоритм верификации, чтобы понять, что \ref{figure:features_example:2} не является подструктурой \ref{figure:features_example:1}

  \item Примером количественной фичи может быть <<Количество молекул брома в соединении>>. Данная фича более информативная, чем предыдущая. По ней можно сразу понять, что в запросе \ref{figure:features_example:2} 2 молекулы брома, а в элементах базы данных \ref{figure:features_example:0} и \ref{figure:features_example:1} их 0 и 1 соответственно, а значит запрос \ref{figure:features_example:2} не является подструктурой обоих элементов базы данных.  
\end{itemize}

На практике чаще встречаются бинарные фичи, так как количественную фичу $N$ можно разбить на несколько интервалов и задать интервалы бинарными фичами <<$N > x_1$>>, <<$N > x_2$>>, $\ldots $ и далее работать с бинарными значениями, что обычно является сильно более компактным и лишь немного менее информативным способом представить количественные фичи. 

Фингерпринтом молекулы называют битовую строку фиксированной длины, в которой $i$~-й бит равен единице или нулю в зависимости от наличия или отсутствия у молекулы фичи с номером $i$. Тогда построение индекса представляет из себя построение фингерпринта для каждой молекулы базы данных по заданному набору фич. А фильтрация по такому индексу предполагает проверку для каждого элемента базы данных, что фингерпринт данной молекулы является надмаской запроса.  

\begin{figure}
  \centering

  \begin{subfigure}[h]{0.3\textwidth}
     \caption{Query}
     \label{figure:features_example:2}
     \chemfig[angle increment=30,bond join=true]{
	 *6(-Br=-(-Br)-=-)
      }
  \end{subfigure}
  \begin{subfigure}[h]{0.3\textwidth}
     \caption{DataBase entry 1}
     \label{figure:features_example:0}
     \chemfig[angle increment=30,bond join=true]{
       *6(-=-(-)-=-)
     }
  \end{subfigure}
  \begin{subfigure}[h]{0.3\textwidth}
     \caption{DataBase entry 2}
     \label{figure:features_example:1}
     \chemfig[angle increment=30,bond join=true]{
	 *6(-Br=-(-)-=-)
      }
  \end{subfigure}

  \caption{Пример выделения фичей}
  \label{figure:features_example}

\end{figure}


Современные решения данной задачи концентрируют своё внимание на ускорении поиска с помощью построения качественного фингерпринта, предполагая, что стадия фильтрации будет происходить перебором всех фингерпринтов. Однако количество открытых молекул быстро увеличивается. {\color{red} статистика изменений размера базы pubchem: (27 млн в 2011, CT-index), (~94 млн в 2017, sachem), (115 млн в 2023)}. Поэтому есть предположение, что в будущем крассические подходы к скринингу будут дорожать.  Например, уже сейчас при работе с базой данных размером $4 \cdot 10^9$ {\color{red} Дима сказал, что такая база у Quantori есть и обещал найти её}. Bingo fingerprint (один из популярных фингерпринтов) для всей базы данных будет весить $1.25$ Тб, что потребует для быстрой работы дорогие ресурсы (либо дорогую большую оперативную память, либо дорогие быстрые твердотельные накопители). {\color{red} хорошо бы потестить наше решение на большой базе. А то пока это голословно утверждать, что наше решение успешно будет работать на таких данных}

Именно поэтому есть интерес к развитию альтернативных подходов к скринингу. К сожалению, поиск хотя бы одной надструктуры в базе данных для запроса является OV трудной {\color{red} тут надо быть осторожным, так как я сам придумал доказательство OV трудности}, поэтому не найдено решение, которое бы в общем случае работало бы сильно быстрее.

В данной статье мы рассматриваем новый подход к скринингу, основанный на бинарном дереве Ball-Tree, который в среднем работает лучше полного перебора, что позволяет ускорить подструктурный поиск. 

\section{Future development}

Представленный подход может быть в дальнейшем модернизирован, так как классические фингерпринты обладают рядом недостатков, которых теоретически можно избежать в реализации с деревом:  

\begin{itemize}
  \item В них не может быть слишком много фич, так как фингерпринты оптимизируются для полного перебора, а значит не могут занимать слишком много памяти.  
  \item Фингерпринты плохо работают со специфичными молекулами, так как не могут разобрать частные случаи и выделить особенные фичи.  
\end{itemize}

Таким образом, предполагается сделать следующий алгоритм:

\begin{enumerate}
  \item Для данного множества выделить фичу, которая делит его примерно попалам (по наличию/отсутсвию фичи. Можно выделять несколько фичей и решать задачу о выборе комбинации фичей так, чтобы делить множество примерно поровну)
  \item Делить множество попалам на 2 поддерева согласно найденной фиче.
  \item Рекурсивно продолжать в детях. 
\end{enumerate}

Такой подход позволит сэкономить ресурсы, так как в хорошем случае можно будет полностью отказаться от фингерпринтов. А на каждом шаге дерева нужно будет проверить только одну фичу. Также можно будет переиспользовать информацю собранную о запросе и молекулах в листе при спуске к листу (некоторые filter-and-verify подходы так делают, но опять же наш подход предположительно должен быть лучше благодаря его адаптивности к конкретным данным поддереве)
